<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ツボマップ｜症状で即切替（該当ツボのみ表示）</title>
<style>
  :root { --accent:#0f766e; }
  *{box-sizing:border-box}
  body{margin:0;background:#fafafa;color:#222;font-family:"Noto Sans JP","Yu Gothic",sans-serif}
  header{background:#444;color:#fff;padding:.9rem 1rem;font-weight:600}
  .wrap{max-width:1200px;margin:18px auto;padding:0 14px;display:grid;grid-template-columns:320px 1fr;gap:16px}
  @media(max-width:960px){.wrap{grid-template-columns:1fr}}
  .panel{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:14px;box-shadow:0 1px 4px rgba(0,0,0,.04)}
  .panel h2{margin:.2rem 0 .8rem;font-size:1.05rem}
  select{width:100%;padding:.6rem .7rem;border:1px solid #d7d7d7;border-radius:10px;background:#fff;font-size:.95rem;margin-bottom:10px}
  .btn-clear{padding:.5rem .8rem;border-radius:10px;border:1px solid var(--accent);background:#fff;color:var(--accent);cursor:pointer;font-weight:600}
  object{width:100%;height:auto;display:block;border-radius:10px;border:1px solid #e6e6e6;background:#fff}

  /* ---- SVG制御（“該当だけ残す”）---- */
  ._hide { display:none !important; }
  ._show { display:inline !important; filter:drop-shadow(0 0 2px rgba(15,118,110,.7)); }
  /* 自動生成マーカー（テキスト位置に応急で打つ点） */
  ._auto-marker { fill:#0f766e; stroke:#fff; stroke-width:2; }

  /* 解説 */
  .notes{display:grid;gap:10px;margin-top:10px;max-height:420px;overflow:auto;border-top:1px dashed #eee;padding-top:10px}
  .note{border:1px solid #e9f0ef;background:#fff;border-radius:12px;padding:10px}
  .note h3{margin:.1rem 0 .3rem;font-size:1rem;color:#0f4d4a}
  .note p{margin:.2rem 0 .2rem;font-size:.92rem;line-height:1.5}
</style>
</head>
<body>
<header>ツボマップ（症状選択で即反映・該当のみ表示）</header>

<div class="wrap">
  <!-- 左：操作と解説 -->
  <aside class="panel">
    <h2>症状から選ぶ</h2>
    <select id="sym" aria-label="症状を選択">
      <option value="">— 症状を選択 —（全表示）</option>
      <option>肩こり</option>
      <option>頭痛</option>
      <option>顎関節痛</option>
      <option>鼻閉・花粉症</option>
      <option>逆流性食道炎</option>
      <option>PMS</option>
      <option>坐骨神経痛</option>
      <option>足関節痛</option>
    </select>
    <button class="btn-clear" id="reset">全表示に戻す</button>

    <h2 style="margin-top:14px;">選択中のツボ解説</h2>
    <div id="notes" class="notes">
      <div style="color:#666;font-size:.9rem">症状を選ぶと表示されます。</div>
    </div>
  </aside>

  <!-- 右：SVG -->
  <main class="panel">
    <object id="svgObj" type="image/svg+xml" data="tsubo_map_front_medical_web.svg" aria-label="ツボマップ"></object>
  </main>
</div>

<script>
/* ===== 症状→ツボ ===== */
const symptomMap = {
  "肩こり": ["肩井","風池","天柱","肩髃","曲池","合谷"],
  "頭痛": ["百会","印堂","風池","太衝","合谷"],
  "顎関節痛": ["頰車","下関","合谷","太渓"],
  "鼻閉・花粉症": ["迎香","印堂","百会","合谷","上星"],
  "逆流性食道炎": ["内関","中脘","膻中","足三里"],
  "PMS": ["三陰交","太衝","関元","気海"],
  "坐骨神経痛": ["環跳","殷門","委中","承山","承扶","陽陵泉"],
  "足関節痛": ["解谿","崑崙","太谿","丘墟","申脈"]
};

/* ===== ツボ解説（簡潔） ===== */
const info = {
  "肩井":{loc:"肩中央の僧帽筋上",eff:"肩こり・頭重",how:"指腹で90秒×1-2回"},
  "風池":{loc:"後頭骨下のくぼみ",eff:"頭痛・眼精疲労",how:"後頭側へ軽圧"},
  "天柱":{loc:"後頭部の生え際外側",eff:"首こり",how:"前屈し30秒×3"},
  "肩髃":{loc:"肩前外側のくぼみ",eff:"肩痛",how:"円揉み"},
  "曲池":{loc:"肘しわ外端",eff:"肘痛・肩こり補助",how:"押圧30秒×3"},
  "合谷":{loc:"第1-2中手骨の合流点",eff:"頭痛・歯痛・鼻症状",how:"30-60秒 軽痛気持ち"},
  "百会":{loc:"頭頂正中",eff:"頭痛・自律神経",how:"軽圧＋深呼吸"},
  "印堂":{loc:"眉間中央",eff:"鼻閉・ストレス",how:"点圧"},
  "太衝":{loc:"第1-2中足骨間",eff:"頭痛・PMS",how:"30秒×3"},
  "頰車":{loc:"下顎角前の咬筋上",eff:"顎関節痛",how:"じんわり緩める"},
  "下関":{loc:"頬骨弓の下",eff:"顎関節痛",how:"軽く開口し軽圧"},
  "太渓":{loc:"内果とアキレス腱間",eff:"腰痛・冷え",how:"温め＋軽圧"},
  "迎香":{loc:"小鼻外側",eff:"鼻閉",how:"上外へ軽圧"},
  "上星":{loc:"生え際正中1指上",eff:"鼻閉・頭重",how:"点圧"},
  "内関":{loc:"手首中央から3指上",eff:"逆流・吐き気",how:"持続軽圧"},
  "中脘":{loc:"臍と剣状突起の中点",eff:"胃もたれ・逆流",how:"食後を避け円揉"},
  "膻中":{loc:"乳頭間正中",eff:"胸のつかえ",how:"掌で包む"},
  "足三里":{loc:"脛骨稜外1・下3",eff:"胃腸・全身",how:"やや強め"},
  "三陰交":{loc:"内果上4指",eff:"PMS・冷え",how:"温め＋軽圧"},
  "関元":{loc:"臍下3寸",eff:"下腹の冷え",how:"保温＋軽圧"},
  "気海":{loc:"臍下1.5寸",eff:"疲労・冷え",how:"腹式呼吸併用"},
  "環跳":{loc:"股関節外側のくぼみ",eff:"坐骨神経痛",how:"殿筋リリース併用"},
  "殷門":{loc:"大腿後面中央",eff:"坐骨神経痛",how:"フォームローラー"},
  "委中":{loc:"膝窩中央",eff:"腰背部痛",how:"軽屈で押圧"},
  "承山":{loc:"腓腹筋V字下端",eff:"ふくらはぎ張り",how:"つま先立ち併用"},
  "承扶":{loc:"坐骨結節の下",eff:"坐骨神経痛",how:"短時間"},
  "陽陵泉":{loc:"腓骨頭前下",eff:"膝外側痛",how:"外側ラインをほぐす"},
  "解谿":{loc:"足首前面腱間",eff:"足関節痛",how:"可動域内で軽圧"},
  "崑崙":{loc:"外果とアキレス腱間",eff:"足関節痛・腰痛",how:"短時間指圧"},
  "丘墟":{loc:"外果前下",eff:"捻挫後ケア",how:"円揉"},
  "申脈":{loc:"外果直下",eff:"足首安定",how:"骨沿いに軽圧"}
};

/* ===== 内部状態 ===== */
const sym   = document.getElementById('sym');
const notes = document.getElementById('notes');
const svgObj= document.getElementById('svgObj');

let svgDoc=null;
let nameToDot=new Map();      // ツボ名 -> 代表点(SVG要素)
let nameToTexts=new Map();    // ツボ名 -> [text要素...]
let nameToAux=new Map();      // ツボ名 -> [短いline...]
let allPoints=[], allTexts=[], allShortLines=[];
let autoLayer=null;

const norm = s => (s||"").replace(/\s+/g,"").replace(/[　]/g,"").trim();
const isSmallBlackPath = el => {
  if(el.tagName!=="path") return false;
  const st = getComputedStyle(el);
  const fill = (el.getAttribute('fill')||st.fill||'').toLowerCase();
  const stroke= (el.getAttribute('stroke')||st.stroke||'').toLowerCase();
  const bb = el.getBBox(); const area = bb.width * bb.height;
  const dark = /#000|black|#111|#222|rgb\(0,\s*0,\s*0\)/.test(fill) || (!fill && /#000|black/.test(stroke));
  return dark && area>0 && area<160; // 小さめで黒っぽい形
};

/* ===== 1) SVGロード後：頑丈ひも付け ===== */
svgObj.addEventListener('load', () => {
  svgDoc = svgObj.contentDocument; if(!svgDoc) return;
  const root = svgDoc.documentElement;

  // 自動マーカー用レイヤ（前面）
  autoLayer = svgDoc.createElementNS("http://www.w3.org/2000/svg","g");
  autoLayer.setAttribute('id','auto-layer'); root.appendChild(autoLayer);

  // すべての text を収集（tspanを結合して名前正規化）
  const texts = Array.from(svgDoc.querySelectorAll('text'));
  texts.forEach(t=>{
    const raw = Array.from(t.querySelectorAll('tspan')).map(s=>s.textContent).join('') || t.textContent;
    const name = norm(raw);
    if(!name) return;
    if(!nameToTexts.has(name)) nameToTexts.set(name,[]);
    nameToTexts.get(name).push(t);
  });
  allTexts = texts;

  // 点候補：circle/ellipse/小さい黒path
  const circles = Array.from(svgDoc.querySelectorAll('circle'));
  const ellipses= Array.from(svgDoc.querySelectorAll('ellipse'));
  const smallPs = Array.from(svgDoc.querySelectorAll('path')).filter(isSmallBlackPath);
  allPoints = [...circles, ...ellipses, ...smallPs];

  // テキスト中心に最も近い点を代表点に（見つからなければ自動マーカー作成）
  nameToTexts.forEach((arr,name)=>{
    let sx=0, sy=0;
    arr.forEach(t=>{ const b=t.getBBox(); sx+=b.x+b.width/2; sy+=b.y+b.height/2; });
    const tx=sx/arr.length, ty=sy/arr.length;

    let best=null, bestD=Infinity;
    allPoints.forEach(p=>{
      let px,py;
      if(p.tagName==='circle'||p.tagName==='ellipse'){ px=+p.getAttribute('cx')||0; py=+p.getAttribute('cy')||0; }
      else { const bb=p.getBBox(); px=bb.x+bb.width/2; py=bb.y+bb.height/2; }
      const d2=(px-tx)*(px-tx)+(py-ty)*(py-ty);
      if(d2<bestD){ bestD=d2; best=p; }
    });

    if(best){
      nameToDot.set(name,best);
    }else{
      // 無ければテキスト位置に仮マーカーを生成（確実に可視化）
      const mk = svgDoc.createElementNS("http://www.w3.org/2000/svg","circle");
      mk.setAttribute('cx',tx); mk.setAttribute('cy',ty); mk.setAttribute('r',5);
      mk.setAttribute('class','_auto-marker');
      autoLayer.appendChild(mk);
      nameToDot.set(name,mk);
      allPoints.push(mk);
    }
  });

  // 短いlineとの関連付け（ラベル引き出し線など）
  const lines = Array.from(svgDoc.querySelectorAll('line'));
  const dist=(x1,y1,x2,y2)=>Math.hypot(x1-x2,y1-y2);
  const len = ln=>Math.hypot((+ln.getAttribute('x1')||0)-(+ln.getAttribute('x2')||0),
                             (+ln.getAttribute('y1')||0)-(+ln.getAttribute('y2')||0));
  allShortLines = lines.filter(ln=>len(ln)<=60);
  nameToDot.forEach((dot,name)=>{
    let px,py;
    if(dot.tagName==='circle'||dot.tagName==='ellipse'){ px=+dot.getAttribute('cx')||0; py=+dot.getAttribute('cy')||0; }
    else { const bb=dot.getBBox(); px=bb.x+bb.width/2; py=bb.y+bb.height/2; }
    const near = allShortLines.filter(ln=>{
      const x1=+ln.getAttribute('x1')||0, y1=+ln.getAttribute('y1')||0;
      const x2=+ln.getAttribute('x2')||0, y2=+ln.getAttribute('y2')||0;
      const d=Math.min(dist(px,py,x1,y1), dist(px,py,x2,y2));
      return d<=40;
    });
    if(near.length) nameToAux.set(name,near);
  });

  // 初期：全表示
  showOnly([]); renderNotes([]);
});

/* ===== 2) 表示制御：全隠し→対象のみ再表示 ===== */
let lastNames = []; // iOSのselect挙動対策（同値多発防止）
function showOnly(names){
  if(!svgDoc) return;
  const key = JSON.stringify(names);
  if (key === JSON.stringify(lastNames)) return; // 無駄な再描画を抑止
  lastNames = names.slice(0);

  const want=new Set(names.map(norm));

  // まず“全候補”を非表示
  allPoints.forEach(el=>el.classList.add('_hide'));
  allTexts.forEach(t=>t.classList.add('_hide'));
  allShortLines.forEach(l=>l.classList.add('_hide'));

  if(!names.length){
    // 全表示
    allPoints.forEach(el=>el.classList.remove('_hide','_show'));
    allTexts.forEach(t=>t.classList.remove('_hide'));
    allShortLines.forEach(l=>l.classList.remove('_hide'));
    return;
  }
  // 対象のみ表示
  want.forEach(n=>{
    const d=nameToDot.get(n);
    if(d){ d.classList.remove('_hide'); d.classList.add('_show'); }
    (nameToTexts.get(n)||[]).forEach(t=>t.classList.remove('_hide'));
    (nameToAux.get(n)||[]).forEach(l=>l.classList.remove('_hide'));
  });
}

/* ===== 3) 解説描画 ===== */
function renderNotes(names){
  if(!names.length){ notes.innerHTML='<div style="color:#666;font-size:.9rem">症状を選ぶと表示されます。</div>'; return; }
  notes.innerHTML='';
  names.forEach(n=>{
    const d=info[n]||{};
    const el=document.createElement('div'); el.className='note';
    el.innerHTML = `<h3>${n}</h3>
      <p><strong>位置：</strong>${d.loc||"（調整中）"}</p>
      <p><strong>効能：</strong>${d.eff||"（調整中）"}</p>
      <p><strong>押し方：</strong>${d.how||"（調整中）"}</p>`;
    notes.appendChild(el);
  });
}

/* ===== 4) プルダウン即反映＋全表示ボタン ===== */
function apply(){
  const key = sym.value;
  const names = key ? (symptomMap[key]||[]) : [];
  showOnly(names); renderNotes(names);
}
sym.addEventListener('change', apply);
sym.addEventListener('input',  apply);
document.getElementById('reset').addEventListener('click', ()=>{ sym.value=""; showOnly([]); renderNotes([]); });
</script>
</body>
</html>
